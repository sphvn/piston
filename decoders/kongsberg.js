// Generated by LiveScript 1.2.0
(function(){
  var ref$, dropWhile, span, moment, length, startChar, endChar, buffer, unpack;
  ref$ = require('prelude-ls').Str, dropWhile = ref$.dropWhile, span = ref$.span;
  moment = require('moment');
  length = function(it){
    return it.length;
  };
  startChar = "D";
  endChar = "\r";
  buffer = "";
  this.bufferSize = function(){
    return length(buffer);
  };
  this.flush = function(){
    return buffer = "";
  };
  this.receive = function(chunk){
    var msgs, ref$, buf, msg;
    if (this.bufferSize() >= 16000) {
      this.flush();
    }
    msgs = [];
    for (;;) {
      ref$ = unpack(buffer, chunk), buf = ref$[0], msg = ref$[1];
      buffer = buf;
      if (msg == null) {
        return msgs;
      }
      msgs.push(msg);
      chunk = "";
    }
  };
  unpack = function(buf, chunk){
    var _buf, ref$, msg;
    _buf = dropWhile((function(it){
      return it !== startChar;
    }), buf + chunk);
    if (_buf.indexOf(endChar) === -1) {
      return [_buf, null];
    }
    ref$ = span((function(it){
      return it !== endChar;
    }), _buf), msg = ref$[0], _buf = ref$[1];
    switch (false) {
    case msg[0] !== startChar:
      return [_buf, msg];
    default:
      return [_buf, null];
    }
  };
  this.decode = function(msg){
    var talker, sentence, parts;
    talker = "";
    sentence = "Simrad ASCII";
    parts = msg.split(",");
    return {
      talker: talker,
      sentence: sentence,
      time: moment(parts[1], "HHmmssSS"),
      channel: parseInt(parts[0].substr(1)),
      depth: parseFloat(parts[2]),
      backscatter: parseFloat(parts[3]),
      transducer: parseInt(parts[4]),
      slope: parseInt(parts[5])
    };
  };
}).call(this);
