// Generated by LiveScript 1.2.0
(function(){
  var ref$, dropWhile, takeWhile, span, drop, floor, splitAt, moment, puts, length, exspan, buffer, unpack, decoders, multiSplit, vtgMode, gnssMode, parseDdmm, invalid, checksum, slice$ = [].slice;
  ref$ = require('prelude-ls').Str, dropWhile = ref$.dropWhile, takeWhile = ref$.takeWhile, span = ref$.span;
  ref$ = require('prelude-ls'), drop = ref$.drop, floor = ref$.floor, splitAt = ref$.splitAt;
  moment = require('moment');
  puts = require('util').puts;
  length = function(it){
    return it.length;
  };
  exspan = function(c, xs){
    var ref$, x, y;
    ref$ = span((function(it){
      return it !== c;
    }), xs), x = ref$[0], y = ref$[1];
    return [x, drop(length(c), y)];
  };
  buffer = "";
  this.bufferSize = function(){
    return length(buffer);
  };
  this.flush = function(){
    return buffer = "";
  };
  this.receive = function(chunk){
    var msgs, ref$, buf, msg;
    if (this.bufferSize() >= 16000) {
      this.flush();
    }
    msgs = [];
    for (;;) {
      ref$ = unpack(buffer, chunk), buf = ref$[0], msg = ref$[1];
      buffer = buf;
      if (msg == null) {
        return msgs;
      }
      msgs.push(msg);
      chunk = "";
    }
  };
  unpack = function(buf, chunk){
    var _buf, ref$, msg;
    _buf = dropWhile((function(it){
      return it !== "$";
    }), buf + chunk);
    if (_buf.indexOf("\r") === -1) {
      return [_buf, null];
    }
    ref$ = span((function(it){
      return it !== "\r";
    }), _buf), msg = ref$[0], _buf = ref$[1];
    switch (false) {
    case msg[0] !== "$":
      return [_buf, msg];
    default:
      return [_buf, null];
    }
  };
  this.decode = function(msg){
    var _msg, ref$, checksum, prefix, talker, sentence, parts, decode;
    _msg = drop(1, msg);
    ref$ = exspan('*', _msg), _msg = ref$[0], checksum = ref$[1];
    if (invalid(checksum, _msg)) {
      return null;
    }
    ref$ = exspan(',', _msg), prefix = ref$[0], _msg = ref$[1];
    talker = prefix.substr(0, 2);
    sentence = prefix.substr(2);
    parts = _msg.split(",");
    decode = decoders[sentence.toUpperCase()];
    return import$({
      talker: talker,
      sentence: sentence
    }, decode != null ? decode.apply(this, parts) : void 8);
  };
  decoders = {
    HDT: function(heading, type){
      return {
        heading: parseFloat(heading),
        headingType: type
      };
    },
    HDM: function(heading, type){
      return {
        heading: parseFloat(heading),
        headingType: type
      };
    },
    VTG: function(cogT, t, cogM, m, sogKn, n, sogKph, k, mode){
      return {
        cog: {
          'true': parseFloat(cogT),
          magnetic: parseFloat(cogM)
        },
        sog: {
          knots: parseFloat(sogKn),
          kph: parseFloat(sogKph)
        },
        mode: {
          code: mode,
          desc: vtgMode(mode)
        }
      };
    },
    GGA: function(time, lat, lath, lon, lonh, quality, sats, hdop, alt, altU, gsep, gsepU, age, refid){
      var q;
      q = parseInt(quality);
      return {
        time: moment.utc(time, "HHmmss.SS"),
        wgs84: {
          lat: parseDdmm(lat, lath),
          lon: parseDdmm(lon, lonh),
          elh: parseFloat(alt) + parseFloat(gsep)
        },
        quality: {
          code: q,
          desc: gnssMode(q)
        },
        satellites: parseInt(sats),
        hdop: parseFloat(hdop),
        correctionAge: parseInt(age),
        referenceStation: parseInt(refid)
      };
    },
    GST: function(time, rms, smajSd, sminSd, ori, latSd, lonSd, elhSd){
      return {
        time: moment.utc(time, "HHmmss.SS"),
        rms: parseFloat(rms),
        standardDeviation: {
          semiMajor: parseFloat(smajSd),
          semiMinor: parseFloat(sminSd),
          lat: parseFloat(latSd),
          lon: parseFloat(lonSd),
          elh: parseFloat(elhSd)
        },
        orientation: parseFloat(ori)
      };
    },
    ZDA: function(time, day, month, year, tzH, tzM){
      var timedate;
      timedate = year + "-" + month + "-" + day + " " + time;
      return {
        time: moment.utc(timedate, "yyyy-MM-DD HHmmss.SS"),
        timezone: {
          hours: parseInt(tzH),
          minutes: parseInt(tzM)
        }
      };
    },
    GSV: function(n, i, t){
      var sats, ss, s;
      sats = slice$.call(arguments, 3);
      ss = multiSplit(4, sats);
      return {
        totalParts: parseInt(n),
        partId: parseInt(i),
        totalSats: parseInt(t),
        sats: (function(){
          var i$, ref$, len$, results$ = {};
          for (i$ = 0, len$ = (ref$ = ss).length; i$ < len$; ++i$) {
            s = ref$[i$];
            results$[parseInt(s[0])] = {
              elevation: parseInt(s[1]),
              azimuth: parseInt(s[2]),
              snr: parseInt(s[3])
            };
          }
          return results$;
        }())
      };
    }
  };
  multiSplit = function(n, xs){
    var go;
    go = function(acc, xs){
      var ref$, ys, zs;
      switch (false) {
      case xs.length !== 0:
        return acc;
      default:
        ref$ = splitAt(n, xs), ys = ref$[0], zs = ref$[1];
        return go(acc.concat([ys]), zs);
      }
    };
    return go([], xs);
  };
  vtgMode = function(m){
    switch (m) {
    case 'A':
      return "Autonomous";
    case 'D':
      return "Differential";
    case 'E':
      return "Dead Reckoning";
    case 'M':
      return "Manual Input";
    case 'S':
      return "Simulator";
    case 'N':
      return "Not Valid";
    default:
      return "Unknown";
    }
  };
  gnssMode = function(m){
    switch (m) {
    case 0:
      return "Not Valid";
    case 1:
      return "Standalone";
    case 2:
      return "Differential";
    case 3:
      return "Precise";
    case 4:
      return "Kinematic Fixed";
    case 5:
      return "Kinematic Float";
    case 6:
      return "Dead Reckoning";
    case 7:
      return "Manual Input";
    case 8:
      return "Simulator";
    case 9:
      return "Kinematic Float GPS/Glonass";
    default:
      return "Unknown";
    }
  };
  parseDdmm = function(str, hem){
    var num, intDegs, decMins, decDegs;
    num = parseFloat(str);
    intDegs = floor(num / 100.0);
    decMins = num - intDegs * 100;
    decDegs = intDegs + decMins / 60.0;
    return /^[ws]$/i.test(hem) ? -decDegs : decDegs;
  };
  invalid = function(cs, msg){
    var chk;
    chk = checksum(msg).toLowerCase();
    return chk !== cs.toLowerCase();
  };
  checksum = function(xs){
    var x, i$, to$, i, hex;
    x = 0;
    for (i$ = 0, to$ = xs.length - 1; i$ <= to$; ++i$) {
      i = i$;
      x = x ^ xs.charCodeAt(i);
    }
    hex = Number(x).toString(16).toUpperCase();
    if (hex.length < 2) {
      return ('00' + hex).slice(-2);
    } else {
      return hex;
    }
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
